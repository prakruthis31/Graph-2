/*
colors, groups array, infectedcount in each group 
T.C = O(V^2)
S.C = O(V)
*/
public class Malware{

    public int minMalwareSpread(int[][] graph, int[] initial) {

        int n = graph.length;
        int[] colors = new int[n]; // which group/color each node belongs to
        Arrays.fill(colors, -1);
        int col = 0;
        for (int i = 0; i < n; i++) { //O(V*V) or O(V+E) E becomes V*V
            if (colors[i] == -1) {
                dfs(graph, colors,i, col);
                col++;
            }
        }
        int[] groups = new int[col]; // how many nodes in each group

        for (int j = 0; j < n; j++) { //O(V)
            groups[colors[j]]++;
        }

        int[] initGroups = new int[col]; // no of infected nodes in each group
        for (int no: initial) {
            initGroups[colors[no]]++;
        }

        int result = Integer.MAX_VALUE;
        for (int node : initial) { //O(V)
            // find node which has max count in groups and only 1 infected count
            int cl = colors[node];
            if (initGroups[cl] == 1) {
                if (result == Integer.MAX_VALUE) {
                    result = node;
                } else if (groups[cl] == groups[colors[result]] && node < result) {
                    // if no of nodes saved is equal then return smaller index
                    result = node;
                } else if (groups[cl] > groups[colors[result]]) {
                    result = node;
                }

            }
        }

        // if result is MAX_VALUE the find lowest index
        if (result == Integer.MAX_VALUE) {
            for (int nd : initial) {
                result = Math.min(result, nd);
            }
        }

        return result;
    }

    public void dfs(int[][] graph,int[] colors, int i, int col) {
        
        //base
        if(colors[i]!=-1) return;
        
        //logic
        colors[i] = col;

        for(int j=0;j<graph.length;j++){
            if(graph[i][j]==1){
                dfs(graph,colors,j,col);
            }
        }
    }
}